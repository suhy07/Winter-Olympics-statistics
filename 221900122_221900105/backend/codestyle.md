# 阿里sprinboot编码规范
## 一、命名风格

1. 代码命名不能以下划线或者美元符号开头或者结尾
2. 代码命名不能以中文拼音或者中文拼音与英文混合方式
3. 类名使用UpperCamCamelCase风格，但DO、PO、DTO、VO、BO等除外
4. 方法名、参数名、变量名统一使用lowerCamelCase，必须遵守驼峰命名
5. 常量名全部大写，单词间用下划线隔开
6. 抽象类必须以Abstract或者Base开头，异常类必须以Exception结尾，测试          
   类以测试的类的名称开头Test结尾
7. 类型与中括号紧挨相连标示数组
8. POJO类中布尔类型变量不要加is前缀
9. 包名统一小写，点分隔符有且有一个自然语义单词
10. 避免在父子类和不同代码块中采用相同变量名
11. 避免不规范的缩写命名
12. 在对元素命名时用完整单词组合表达其意
13. 常量和变量命名时，表示类型放在词尾，如：idList、TERMINATED_TREAD_COUNT
14. 接口、类、方法、模块使用设计模式，命名时要体现具体模式
15. 接口类中的方法和属性不要加任何修饰符，并加上有效的javadoc。
16. 接口和实现类的命名规则：
    1、对于service和dao类，实现类必须用Impl结尾；
    2、如果是形容能力的接口名称，取对应的形容词为接口名 AbstractTranslator实现 Translatable接口
17. 枚举类名加Enum后缀，枚举成员名称全大写，单词间用下划线隔开
18. 各层命名规范：
    A) Service/DAO层命名规约
    1.获取单个对象的方法用get做前缀
    2.获取多个对象的方法用list做前缀，如：listObjects
    3.获取统计值的方法用count做前缀
    4.插入方法用save/insert做前缀
    5.删除方法用delete/remove做前缀
    6.修改方法用update做前缀
    B）领域模型命名规范
    1.数据对象：xxxDO, xxx为数据库表名
    2.数据传输对象：xxxDTO,xxx为业务模型相关名称
    3.展示对象：xxxVO，xxx一般为网页名称
    4.POJO是对DO、DTO、VO、BO的统称，禁止xxxPOJO

## 二、常量定义

1. 代码中禁止出现魔法值
2. 在Long类型中赋值，数值后使用大写L
3. 不要在一个常量类中维护所有常量，要根据功能分开维护
4. 常量的复用层次：
   1.跨应用：放在二方库中，通常在constant目录下
   2.应用内：放在一方库中，通常在constant目录下
   3.子工程内：放在当前子工程constant目录下
   4.包内共享常量：当前包下单独的constant目录下
   5.类内共享常量：直接在类内部private static final定义
5. 如果变量值只在固定的范围内变化，用enum类型定义

## 三、代码格式

1. 如果大括号代码为空直接'{}',大括号内有代码则：左大括号左侧不换行，右侧换行；右大括号右侧换行，左侧如果不跟else等代码换行，否则不换行
2. 小括号和字符之间不能有空格，括号内字符和运算符之间有空格 如：if (a == b)
3. if、for、while、do、switch与括号之间必须有空格
4. 任何二目、三目运算符前后必须有空格
5. 采用4个空格，禁止使用tab
6. 注释的双斜线和内容要有空格
7. 强制类型转换时，右括号与强制转换值之间不用空格
8. 单行字符不超过120个，超过要换行
9. 方法在定义和传参时，必须要加空格
10. IDE的text file encoding 设置为UTF-8；IDE中 文件的换行符使用Unix格式
11. 单个方法尽量不超过80行
12. 不同逻辑、不同语义、不同业务之间的代码插入一个空行分隔符
## 四、OOP规约

4.1 对所有标识符都通用的规则
标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式\w+。

4.2 标识符类型的规则
4.2.1 包名
包名全部小写，连续的单词只是简单地连接起来，不使用下划线。

4.2.2 类名
类名都以UpperCamelCase风格编写。

类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。

测试类的命名以它要测试的类的名称开始，以Test结束。例如，HashTest或HashIntegrationTest。

4.2.3 方法名
方法名都以lowerCamelCase风格编写。

方法名通常是动词或动词短语。

下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：test<MethodUnderTest>_<state>，例如testPop_emptyStack。 并不存在唯一正确的方式来命名测试方法。

4.2.4 常量名
常量名命名模式为CONSTANT_CASE，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？

每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。

4.2.5 非常量字段名
非常量字段名以lowerCamelCase风格编写。

这些名字通常是名词或名词短语。

4.2.6 参数名
参数名以lowerCamelCase风格编写。

参数应该避免用单个字符命名。

4.2.7 局部变量名
局部变量名以lowerCamelCase风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。

虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。

即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。


## 五、集合处理

1. hashCode和equals 的处理遵循以下规则：
   1）只要覆写equals ，就必须要覆写hashCode
   2）因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须覆写这两个方法。
   3）如果自定义对象作为Map的键，那么必须覆写hashCode和equals。
2. ArrayList的subList结果不能强转ArrayList。
3. 使用map的keySet()、values()、entrySet()方法返回对象后不可以对其进行添加元素的操作
4. Collections类返回的对象，如：emptyList()/singletonList()等都是immutablelist不可对其进行添加或者删除元素的操作
5. 在subList场景中，高度注意对原集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生ConcurrentModificationException 异常
6. 使用集合转数组的方法，必须使用集合的toArray(T[] array)，传入的是类型完全一致、长度为0的空数组
7. 在使用Collection接口任何实现类的addAll()方法时，一定要对输入的集合做NEP判断
8. 使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出UnsupportedOperationException异常
   说明：asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。
9. 泛型通配符<? extends T>来接收返回的数据，此写法的泛型集合不能使用add方法，而<? super T>不能使用get方法，作为接口调用赋值时易出错
10. 在无泛型限制定义的集合赋值给泛型限制的集合时，在使用集合元素时，需要进行instanceof判断，避免抛出ClassCastException异常
11. 不要在foreach循环里进行元素的remove/add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁
12. 在JDK7 版本及以上，Comparator 实现类要满足如下三个条件，不然Arrays.sort，Collections.sort 会抛IllegalArgumentException 异常。
    说明：三个条件如下
    1） x，y 的比较结果和y，x 的比较结果相反。
    2） x>y，y>z，则x>z。
    3） x=y，则x，z 比较结果和y，z 比较结果相同。
13. 集合泛型定义时，在JDK7 及以上，使用diamond 语法或全省略。
14. 集合初始化时，指定集合初始值大小。
15. 使用entrySet 遍历Map 类集合KV，而不是keySet 方式进行遍历
16. 高度注意Map类集合K/V能不能存储null值的情况，如下表格：

## 六、并发处理

1. 获取单例对象需要保证线程安全，其中的方法也要保证线程安全。
2. 创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。
3. 线程资源必须通过线程池提供，不允许在应用中自行显式创建线程
4. 线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险
5. SimpleDateFormat 是线程不安全的类，一般不要定义为static变量，如果定义为static，必须加锁，或者使用DateUtils工具类。
6. 必须回收自定义的ThreadLocal变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 ThreadLocal变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用try-finally块进行回收
7. 高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁
8. 对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。
9. 在使用阻塞等待获取锁的方式中，必须在try代码块之外，并且在加锁方法与try代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在finally中无法解锁。
10. 在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。锁的释放规则与锁的阻塞等待方式相同
11. 并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用version作为更新依据
12. 多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，如果在处理定时任务时使用ScheduledExecutorService则没有这个问题
13. 资金相关的金融敏感信息，使用悲观锁策略
14. 使用CountDownLatch进行异步转同步操作，每个线程退出前必须调用countDown方法，线程执行代码注意catch异常，确保countDown方法被执行到，避免主线程无法执行至await方法，直到超时才返回结果
15. 避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降
16. 在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优化问题隐患(可参考 The "Double-Checked Locking is Broken" Declaration)，推荐解决方案中较为简单一种（适用于JDK5及以上版本），将目标属性声明为 volatile型
17. volatile解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。
18. HashMap在容量不够进行resize时由于高并发可能出现死链，导致CPU飙升，在开发过程中可以使用其它数据结构或加锁来规避此风险
19. ThreadLocal对象使用static修饰，ThreadLocal无法解决共享对象的更新问题
